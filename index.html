<!DOCTYPE html>
<html>
  <head>
    <title>OSM Leaflet Driver Simulation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      #map {
        height: 100%;
        width: 100%;
      }
    </style>
  </head>
  <body onload="initMap()">
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
    <script src="https://rawgit.com/bbecquet/Leaflet.RotatedMarker/master/leaflet.rotatedMarker.js"></script>
    <script>
      let map;
      const driverRoutes = [];
      const DRIVERS_COUNT = 20;
      const UPDATE_INTERVAL = 2000;
      const VEHICLE_IMAGES = [
        "https://raw.githubusercontent.com/Klajdi424/image/refs/heads/main/OIP__5_-removebg-preview.png",
        "https://raw.githubusercontent.com/Klajdi424/image/refs/heads/main/OIP__6_-removebg-preview.png",
        "https://raw.githubusercontent.com/Klajdi424/image/refs/heads/main/OIP__7_-removebg-preview.png",
        "https://raw.githubusercontent.com/Klajdi424/image/refs/heads/main/driver.png"
      ];
      function initMap() {
        const params = new URLSearchParams(window.location.search);
        const userLat = parseFloat(params.get("userLat")) || 41.1533;
        const userLng = parseFloat(params.get("userLng")) || 20.1683;
        const userLoc = [userLat, userLng];
        map = L.map("map", { center: userLoc, zoom: 10, zoomControl: false });
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        const userIcon = L.icon({
          iconUrl:
            "https://raw.githubusercontent.com/Klajdi424/image/refs/heads/main/Your_paragraph_text__4_-removebg-preview.png",
          iconSize: [50, 50],
          iconAnchor: [25, 25]
        });
        L.marker(userLoc, { icon: userIcon }).addTo(map);
        const bounds = L.latLngBounds(userLoc, userLoc);
        const routePromises = [];
        for (let i = 0; i < DRIVERS_COUNT; i++) {
          const start = randomPoint(userLoc, 0.05);
          const end = randomPoint(userLoc, 0.05);
          bounds.extend([start.lat, start.lng]);
          bounds.extend([end.lat, end.lng]);
          routePromises.push(createDriverRoute(start, end, i % VEHICLE_IMAGES.length));
        }
        map.fitBounds(bounds);
        Promise.all(routePromises).then((results) => {
          results.forEach((result) => {
            const vehicleIcon = L.icon({
              iconUrl: VEHICLE_IMAGES[result.vehicleImageIndex],
              iconSize: [50, 50],
              iconAnchor: [25, 25]
            });
            const marker = L.marker(result.routePoints[0], { icon: vehicleIcon }).addTo(map);
            driverRoutes.push({
              marker: marker,
              routePoints: result.routePoints,
              routeIndex: 0
            });
          });
        });
        setInterval(() => {
          driverRoutes.forEach(animateDriverMovement);
        }, UPDATE_INTERVAL);
      }
      function randomPoint(center, range) {
        return {
          lat: center[0] + (Math.random() * 2 - 1) * range,
          lng: center[1] + (Math.random() * 2 - 1) * range
        };
      }
      function createDriverRoute(start, end, vehicleImageIndex) {
        return new Promise((resolve, reject) => {
          const router = L.Routing.osrmv1();
          router.route(
            [
              new L.Routing.Waypoint(L.latLng(start.lat, start.lng)),
              new L.Routing.Waypoint(L.latLng(end.lat, end.lng))
            ],
            function (err, routes) {
              if (!err && routes && routes.length) {
                const routePoints = routes[0].coordinates;
                resolve({ routePoints: routePoints, vehicleImageIndex: vehicleImageIndex });
              } else {
                reject(err);
              }
            }
          );
        });
      }
      function animateDriverMovement(driver) {
        if (driver.routePoints && driver.routePoints.length) {
          const nextIndex = (driver.routeIndex + 1) % driver.routePoints.length;
          const currentPoint = driver.routePoints[driver.routeIndex];
          const nextPoint = driver.routePoints[nextIndex];
          smoothMarkerTransition(driver.marker, currentPoint, nextPoint);
          driver.routeIndex = nextIndex;
        }
      }
      function smoothMarkerTransition(marker, start, end) {
        const steps = 30;
        const stepTime = UPDATE_INTERVAL / steps;
        let stepCount = 0;
        const latDelta = (end.lat - start.lat) / steps;
        const lngDelta = (end.lng - start.lng) / steps;
        const interval = setInterval(() => {
          stepCount++;
          const newLat = start.lat + latDelta * stepCount;
          const newLng = start.lng + lngDelta * stepCount;
          marker.setLatLng([newLat, newLng]);
          if (stepCount >= steps) clearInterval(interval);
        }, stepTime);
      }
    </script>
  </body>
</html>
```
